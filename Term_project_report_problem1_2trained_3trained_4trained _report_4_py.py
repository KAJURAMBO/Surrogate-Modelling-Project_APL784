# -*- coding: utf-8 -*-
"""term project-report.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yqaCVB6vqOCXwQcX5xxXHD3fNemmWg19

# **Importing Necessary Library**
"""

from numpy import exp,arange
from pylab import meshgrid,cm,imshow,contour,clabel,colorbar,axis,title,show
import numpy as np
import numpy
import matplotlib.pyplot as plt
import scipy.stats as sys
from scipy.stats import norm
import seaborn as sns
import pandas as pd
import random
import matplotlib.pyplot as plt
import argparse
import shelve
from scipy.spatial.distance import squareform, cdist, pdist
from numpy import asarray
from numpy import savetxt
from google.colab import drive
from scipy.stats import weibull_min
import math
#drive.mount('/drive')

# the function that I'm going to plot
def z_func(x1,x2):
 return (exp(0.2*x1+6.2)-exp(0.47*x2+5.0))

x_1=numpy.random.normal(0,1,1000)
x_2=numpy.random.normal(0,1,1000)

"""# **Direct MCS-Problem 1**"""

X,Y = meshgrid(x_1, x_2) # grid of point
Z = z_func(X, Y) # evaluation of the function on the grid
fig = plt.figure()
im = imshow(Z,cmap=cm.RdBu) # drawing the function
# adding the Contour lines with labels
cset = contour(Z,arange(-1,15,0.2),linewidths=2,cmap=cm.Set2)
clabel(cset,inline=True,fmt='%1.1f',fontsize=10)
colorbar(im) # adding the colobar on the right

# latex fashion title
title('$z=exp(0.2*x1+6.2)-exp(0.47*x2+5.0)$')
show()

#print(Z)
#print(x1)
#print(x_1)
Z.shape

from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
import matplotlib.pyplot as plt

fig = plt.figure()

ax = fig.gca(projection='3d')
surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, 
                      cmap=cm.RdBu,linewidth=0, antialiased=False)

ax.zaxis.set_major_locator(LinearLocator(10))
ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f'))

fig.colorbar(surf, shrink=0.5, aspect=10)

plt.show()

def countNegative(Z, n, m):
    count = 0
 
    # Follow the path shown using arrows above
    for i in range(n):
        for j in range(m):
 
            if Z[i][j] < 0:
                count += 1
                
    return count


failure_points=(countNegative(Z, 1000, 1000))

PF=failure_points/1000000
print("Probability Of Failure=",PF)
print("Reliability Index=",norm.ppf(PF))

"""# Model Training-Problem 1-Non linear problem"""

X_1=numpy.random.normal(0,1,40)
X_2=numpy.random.normal(0,1,40)
Y_out = z_func(X_1, X_2)
#print(Y_out)

# save to csv file
savetxt('X_1.csv', X_1, delimiter=',')
savetxt('X_2.csv', X_2, delimiter=',')
df1=pd.read_csv('X_1.csv')
df2=pd.read_csv('X_2.csv')
input_df=pd.concat([df1, df2], axis=1)
savetxt('input.csv', input_df, delimiter=',')
savetxt('Y_out.csv', Y_out, delimiter=',')
output_df=pd.read_csv('Y_out.csv')
#print(output_df)
#print(input_df)

"""# **Model Trainning**-Using RBF multi Quadretic """

# Class to create or use an RBF surrogate model
class RBF:

    
    # Multiquadratic
    def _multiquadric(self, r):
        return np.sqrt(r ** 2 + self.epsilon ** 2)

    

    # radial distance calculation - r = (x-c)
    def _compute_r(self, a, b=None):
        if b is not None:
            #  distance matrix between two matrices or vectors)
            return cdist(a, b, 'minkowski', p=2)
        else:
            # square matrix formation of the the pairwise distance distance for the training locations
            return squareform(pdist(a, 'minkowski', p=2))

    def _compute_N(self, r):

      #dictionary to call our MQ_RBF function
        rbf_dict = {
            "multiquadratic" : self._multiquadric,
          
        }

        return rbf_dict[self.rbf_func](r)

    # Function to train an RBF surrogate using the suplied data and options
    def _train(self):
        r = self._compute_r(self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the specified type
        self.weights = np.linalg.solve(N, self.y_data)  # Solve for the weights vector
            # Predicting Y for given combination of input variables
    def _predict(self):
        r = self._compute_r(self.x_train, self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the trained type
        self.y_pred = np.matmul(N.T, self.weights)  # Use the surrogate to predict new y values
        
          
   #inputs
    def __init__(self, type, x_file='x_train.dat', y_file='y_train.dat', model_db='model.db', rbf_func='gaussian'):

        self.x_data = np.loadtxt(x_file, skiprows=0, delimiter=",")  
        self.x_data = self.x_data.reshape(self.x_data.shape[0], -1)  
        self.rbf_func = rbf_func  
        self.model_db = model_db  
        

        # Check for training or prediction
        if type == 'train':
            self.y_data = np.loadtxt(y_file, skiprows=1, delimiter=",")  # Read output data file
            self.y_data = self.y_data.reshape(self.y_data.shape[0], -1)  # Reshape into 2D matrix (avoids array issues)
            # Compute epsilon based on the standard deviation of the output values for the RBFs that use it
            self.epsilon = np.std(self.y_data)

            self._train()  # Run the model training function

            # Store model parameters
            model_data = shelve.open(model_db)
            model_data['rbf_func'] = self.rbf_func
            model_data['epsilon'] = self.epsilon
            model_data['x_train'] = self.x_data
            model_data['weights'] = self.weights
            #print('\nSurrogate Data:')
            #print('RBF Function: ', model_data['rbf_func'])
            #print('Epsilon: ', model_data['epsilon'])
            #print('Radial Basis Function Weights: ', '\n', model_data['weights'])
            #print('\n', 'Trained surrogate stored in: ', self.model_db)
            model_data.close()

        else:
            # Read previously stored model data from the database
            model_data = shelve.open(model_db)
            self.rbf_func = model_data['rbf_func']
            self.epsilon = model_data['epsilon']
            self.x_train = model_data['x_train']
            self.weights = model_data['weights']

            model_data.close()

            print('\nUsing', self.model_db, 'to predict values...')
            self._predict()  # Run the model prediction function

            # Quick loop to add a header that matches the input file format
            y_head = []
            for i in range(self.y_pred.shape[1]):
                y_head.append('y' + str(i))

            # Convert header list of strings to a single string with commas and write out the predictions to a file
            header = ','.join(y_head)
            np.savetxt('y_pred.dat', self.y_pred, delimiter=',', fmt="%.6f", header=header, comments='')
            print('Predicted values stored in \"y_pred.dat\"')

    # Create and run the RBF class object
surrogate = RBF('train', 'input.csv', 'Y_out.csv', 'problem1_trained_model.csv', 'multiquadratic')

"""# **Predicting The Output-Problem 1**

"""

run=1000000
X_1_predict=numpy.random.normal(0,1,run)
X_2_predict=numpy.random.normal(0,1,run)

# save to csv file
savetxt('X_1_predict.csv', X_1_predict, delimiter=',')
savetxt('X_2_predict.csv', X_2_predict, delimiter=',')
df1=pd.read_csv('X_1_predict.csv')
df2=pd.read_csv('X_2_predict.csv')
input_df=pd.concat([df1, df2], axis=1)
savetxt('input_predict.csv', input_df, delimiter=',')

# Class to create or use an RBF surrogate model
class RBF:

    # Multiquadratic
    def _multiquadric(self, r):
        return np.sqrt(r ** 2 + self.epsilon ** 2)

    

    # Function to compute the radial distance - r = (x-c)
    def _compute_r(self, a, b=None):
        if b is not None:
            # Return the distance matrix between two matrices (or vectors)
            return cdist(a, b, 'minkowski', p=2)
        else:
            # Return a square matrix form of the the pairwise distance distance for the training locations
            return squareform(pdist(a, 'minkowski', p=2))

    def _compute_N(self, r):

        
        rbf_dict = {
            "multiquadratic" : self._multiquadric,
          
        }

        return rbf_dict[self.rbf_func](r)

    # Function to train an RBF surrogate using the given data and options
    def _train(self):
        r = self._compute_r(self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the specified type
        self.weights = np.linalg.solve(N, self.y_data)  # Solve for the weights vector
        
        # predictions
    def _predict(self):
        r = self._compute_r(self.x_train, self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the trained type
        self.y_pred = np.matmul(N.T, self.weights)  # Use the surrogate to predict new y values

          
    # Initialization for the RBF class
    # Defaults are specified for the options, required to pass in whether you are training or predicting
    def __init__(self, type, x_file='x_train.dat', y_file='y_train.dat', model_db='model.db', rbf_func='gaussian'):

        self.x_data = np.loadtxt(x_file, skiprows=0, delimiter=",")  # Read the input locations file
        self.x_data = self.x_data.reshape(self.x_data.shape[0], -1)  # Reshape into 2D matrix (avoids array issues)
        self.rbf_func = rbf_func  # Read user specified options (or the defaults)
        self.model_db = model_db  # Read user specified options (or the defaults)
        

        # Check for training or prediction
        if type == 'train':
            self.y_data = np.loadtxt(y_file, skiprows=1, delimiter=",")  # Read output data file
            self.y_data = self.y_data.reshape(self.y_data.shape[0], -1)  # Reshape into 2D matrix (avoids array issues)
            # Compute epsilon based on the standard deviation of the output values for the RBFs that use it
            self.epsilon = np.std(self.y_data)

            self._train()  # Run the model training function

            # Store model parameters in a Python shelve database
            model_data = shelve.open(model_db)
            model_data['rbf_func'] = self.rbf_func
            model_data['epsilon'] = self.epsilon
            model_data['x_train'] = self.x_data
            model_data['weights'] = self.weights
            print('\nSurrogate Data:')
            print('RBF Function: ', model_data['rbf_func'])
            print('Epsilon: ', model_data['epsilon'])
            print('Radial Basis Function Weights: ', '\n', model_data['weights'])
            print('\n', 'Trained surrogate stored in: ', self.model_db)
            model_data.close()

        else:
            # Read previously stored model data from the database
            model_data = shelve.open(model_db)
            self.rbf_func = model_data['rbf_func']
            self.epsilon = model_data['epsilon']
            self.x_train = model_data['x_train']
            self.weights = model_data['weights']

            model_data.close()

            print('\nUsing', self.model_db, 'to predict values...')
            self._predict()  # Run the model prediction function

            # Quick loop to add a header that matches the input file format
            y_head = []
            for i in range(self.y_pred.shape[1]):
                y_head.append('y' + str(i))

            # Convert header list of strings to a single string with commas and write out the predictions to a file
            header = ','.join(y_head)
            np.savetxt('y_pred.dat', self.y_pred, delimiter=',', fmt="%.6f", header=header, comments='')
            print('Predicted values stored in \"y_pred.dat\"')
            
    # Create and run the RBF class object
surrogate = RBF('predict', 'input_predict.csv', 'Y_out_predicted.csv', 'problem1_trained_model.csv', 'multiquadratic')

df_predicted=pd.read_csv('y_pred.dat')

df_predicted.values.flatten()
sum(n < 0 for n in df_predicted.values.flatten())
probability_of_failure=sum(n < 0 for n in df_predicted.values.flatten())/run
print("Probability of Failure=",probability_of_failure)





"""##**Problem 2 Direct MCS-Cantilever Beam**"""

n=1000000
E=10000000
P=80
muL=30
muB= 0.8359
muH=2.5093

sigL=3
sigB=0.08
sigH=0.25

normal_std_L = np.sqrt(np.log(1 + (sigL/muL)**2))
normal_mean_L= np.log(muL) - normal_std_L**2 / 2

normal_std_H = np.sqrt(np.log(1 + (sigH/muH)**2))
normal_mean_H = np.log(muH) - normal_std_H**2 / 2

def Y(x,y,z):
    return ((0.15)-(4*P*x**3)/(E*y*z**3))

MCS_list_output=[]
mcs_L_input=[]
mcs_B_input=[]
mcs_H_input=[]
for i in range(n):
    mcs_L_sample=np.random.lognormal(normal_mean_L,normal_std_L)
    mcs_B_sample=random.gauss(muB,sigB)
    mcs_H_sample=np.random.lognormal(normal_mean_H,normal_std_H)
    
    mcs_sample=Y(mcs_L_sample,mcs_B_sample,mcs_H_sample)
    MCS_list_output.append(mcs_sample)
    mcs_L_input.append(mcs_L_sample)
    mcs_B_input.append(mcs_B_sample)
    mcs_H_input.append(mcs_H_sample)

Failure_points=[x for x in MCS_list_output if x<0]
length=len(Failure_points)
PF=length/n
print("Probability Of Failure=",PF)
print("Reliability Index=",norm.ppf(PF))

"""# **RBF Model Trainning For Problem 2**"""

n=20
E=10000000
P=80
muL=30;
muB= 0.8359;
muH=2.5093;

sigL=3;
sigB=0.08
sigH=0.25

normal_std_L_RBF = np.sqrt(np.log(1 + (sigL/muL)**2))
normal_mean_L_RBF= np.log(muL) - normal_std_L_RBF**2 / 2

normal_std_H_RBF = np.sqrt(np.log(1 + (sigH/muH)**2))
normal_mean_H_RBF = np.log(muH) - normal_std_H_RBF**2 / 2

def Y(x,y,z):
    return ((0.15)-(4*P*x**3)/(E*y*z**3))

MCS_list_output_RBF=[]
mcs_L_input_RBF=[]
mcs_B_input_RBF=[]
mcs_H_input_RBF=[]
for i in range(n):
    mcs_L_sample_RBF=np.random.lognormal(normal_mean_L_RBF,normal_std_L_RBF)
    mcs_B_sample_RBF=random.gauss(muB,sigB)
    mcs_H_sample_RBF=np.random.lognormal(normal_mean_H_RBF,normal_std_H_RBF)
    
    mcs_sample_RBF=Y(mcs_L_sample_RBF,mcs_B_sample_RBF,mcs_H_sample_RBF)
    MCS_list_output_RBF.append(mcs_sample_RBF)
    mcs_L_input_RBF.append(mcs_L_sample_RBF)
    mcs_B_input_RBF.append(mcs_B_sample_RBF)
    mcs_H_input_RBF.append(mcs_H_sample_RBF)

# save to csv file
savetxt('mcs_L_input_RBF.csv', mcs_L_input_RBF, delimiter=',')
savetxt('mcs_B_input_RBF.csv', mcs_B_input_RBF, delimiter=',')
savetxt('mcs_H_input_RBF.csv', mcs_H_input_RBF, delimiter=',')
df1_RBF=pd.read_csv('mcs_L_input_RBF.csv')
df2_RBF=pd.read_csv('mcs_B_input_RBF.csv')
df3_RBF=pd.read_csv('mcs_H_input_RBF.csv')
input_df_RBF=pd.concat([df1_RBF,df2_RBF,df3_RBF], axis=1)
savetxt('input_RBF.csv', input_df_RBF, delimiter=',')
savetxt('MCS_list_output_RBF.csv',  MCS_list_output_RBF, delimiter=',')
output_df_RBF=pd.read_csv('MCS_list_output_RBF.csv')

#print(input_df_RBF)
#print(MCS_list_output_RBF)

"""# **Training**"""

# Class to create or use an RBF surrogate model
class RBF:

    
    # Multiquadratic
    def _multiquadric(self, r):
        return np.sqrt(r ** 2 + self.epsilon ** 2)

    

    # radial distance calculation - r = (x-c)
    def _compute_r(self, a, b=None):
        if b is not None:
            #  distance matrix between two matrices or vectors)
            return cdist(a, b, 'minkowski', p=2)
        else:
            # square matrix formation of the the pairwise distance distance for the training locations
            return squareform(pdist(a, 'minkowski', p=2))

    def _compute_N(self, r):

      #dictionary to call our MQ_RBF function
        rbf_dict = {
            "multiquadratic" : self._multiquadric,
          
        }

        return rbf_dict[self.rbf_func](r)

    # Function to train an RBF surrogate using the suplied data and options
    def _train(self):
        r = self._compute_r(self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the specified type
        self.weights = np.linalg.solve(N, self.y_data)  # Solve for the weights vector
            # Predicting Y for given combination of input variables
    def _predict(self):
        r = self._compute_r(self.x_train, self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the trained type
        self.y_pred = np.matmul(N.T, self.weights)  # Use the surrogate to predict new y values
        
          
   #inputs
    def __init__(self, type, x_file='x_train.dat', y_file='y_train.dat', model_db='model.db', rbf_func='gaussian'):

        self.x_data = np.loadtxt(x_file, skiprows=0, delimiter=",")  
        self.x_data = self.x_data.reshape(self.x_data.shape[0], -1)  
        self.rbf_func = rbf_func  
        self.model_db = model_db  
        

        # Check for training or prediction
        if type == 'train':
            self.y_data = np.loadtxt(y_file, skiprows=1, delimiter=",")  # Read output data file
            self.y_data = self.y_data.reshape(self.y_data.shape[0], -1)  # Reshape into 2D matrix (avoids array issues)
            # Compute epsilon based on the standard deviation of the output values for the RBFs that use it
            self.epsilon = np.std(self.y_data)

            self._train()  # Run the model training function

            # Store model parameters
            model_data = shelve.open(model_db)
            model_data['rbf_func'] = self.rbf_func
            model_data['epsilon'] = self.epsilon
            model_data['x_train'] = self.x_data
            model_data['weights'] = self.weights
            #print('\nSurrogate Data:')
            #print('RBF Function: ', model_data['rbf_func'])
            #print('Epsilon: ', model_data['epsilon'])
            #print('Radial Basis Function Weights: ', '\n', model_data['weights'])
            print('\n', 'Trained surrogate stored in: ', self.model_db)
            model_data.close()

        else:
            # Read previously stored model data from the database
            model_data = shelve.open(model_db)
            self.rbf_func = model_data['rbf_func']
            self.epsilon = model_data['epsilon']
            self.x_train = model_data['x_train']
            self.weights = model_data['weights']

            model_data.close()

            print('\nUsing', self.model_db, 'to predict values...')
            self._predict()  # Run the model prediction function

            # Quick loop to add a header that matches the input file format
            y_head = []
            for i in range(self.y_pred.shape[1]):
                y_head.append('y' + str(i))

            # Convert header list of strings to a single string with commas and write out the predictions to a file
            header = ','.join(y_head)
            np.savetxt('y_pred.dat', self.y_pred, delimiter=',', fmt="%.6f", header=header, comments='')
            print('Predicted values stored in \"y_pred.dat\"')

    # Create and run the RBF class object
surrogate = RBF('train', 'input_RBF.csv', 'MCS_list_output_RBF.csv', 'problem2_trained_model.csv', 'multiquadratic')

"""# **Predicting the output and Probability of failure for problem 2**"""

n_P2=1000000
E=10000000
P=80
muL=30;
muB= 0.8359;
muH=2.5093;

sigL=3;
sigB=0.08
sigH=0.25

normal_std_L_RBF_predict = np.sqrt(np.log(1 + (sigL/muL)**2))
normal_mean_L_RBF_predict= np.log(muL) - normal_std_L_RBF_predict**2 / 2

normal_std_H_RBF_predict = np.sqrt(np.log(1 + (sigH/muH)**2))
normal_mean_H_RBF_predict = np.log(muH) - normal_std_H_RBF_predict**2 / 2

mcs_L_input_RBF_predict=[]
mcs_B_input_RBF_predict=[]
mcs_H_input_RBF_predict=[]
for i in range(n_P2):
    mcs_L_sample_RBF_predict=np.random.lognormal(normal_mean_L_RBF_predict,normal_std_L_RBF_predict)
    mcs_B_sample_RBF_predict=random.gauss(muB,sigB)
    mcs_H_sample_RBF_predict=np.random.lognormal(normal_mean_H_RBF_predict,normal_std_H_RBF_predict)
    
    mcs_L_input_RBF_predict.append(mcs_L_sample_RBF_predict)
    mcs_B_input_RBF_predict.append(mcs_B_sample_RBF_predict)
    mcs_H_input_RBF_predict.append(mcs_H_sample_RBF_predict)

# save to csv file
savetxt('mcs_L_input_RBF_predict.csv', mcs_L_input_RBF_predict, delimiter=',')
savetxt('mcs_B_input_RBF_predict.csv', mcs_B_input_RBF_predict, delimiter=',')
savetxt('mcs_H_input_RBF_predict.csv', mcs_H_input_RBF_predict, delimiter=',')
df1_RBF_predict=pd.read_csv('mcs_L_input_RBF_predict.csv')
df2_RBF_predict=pd.read_csv('mcs_B_input_RBF_predict.csv')
df3_RBF_predict=pd.read_csv('mcs_H_input_RBF_predict.csv')
input_df_RBF_predict=pd.concat([df1_RBF_predict,df2_RBF_predict,df3_RBF_predict], axis=1)
savetxt('input_RBF_predict.csv', input_df_RBF_predict, delimiter=',')


#print(input_df_RBF)
#print(MCS_list_output_RBF)

"""# **Input to the Trained-Model**"""

# Class to create or use an RBF surrogate model
class RBF:

    
    # Multiquadratic
    def _multiquadric(self, r):
        return np.sqrt(r ** 2 + self.epsilon ** 2)

    

    # radial distance calculation - r = (x-c)
    def _compute_r(self, a, b=None):
        if b is not None:
            #  distance matrix between two matrices or vectors)
            return cdist(a, b, 'minkowski', p=2)
        else:
            # square matrix formation of the the pairwise distance distance for the training locations
            return squareform(pdist(a, 'minkowski', p=2))

    def _compute_N(self, r):

      #dictionary to call our MQ_RBF function
        rbf_dict = {
            "multiquadratic" : self._multiquadric,
          
        }

        return rbf_dict[self.rbf_func](r)

    # Function to train an RBF surrogate using the suplied data and options
    def _train(self):
        r = self._compute_r(self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the specified type
        self.weights = np.linalg.solve(N, self.y_data)  # Solve for the weights vector
            # Predicting Y for given combination of input variables
    def _predict(self):
        r = self._compute_r(self.x_train, self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the trained type
        self.y_pred = np.matmul(N.T, self.weights)  # Use the surrogate to predict new y values
        
          
   #inputs
    def __init__(self, type, x_file='x_train.dat', y_file='y_train.dat', model_db='model.db', rbf_func='gaussian'):

        self.x_data = np.loadtxt(x_file, skiprows=0, delimiter=",")  
        self.x_data = self.x_data.reshape(self.x_data.shape[0], -1)  
        self.rbf_func = rbf_func  
        self.model_db = model_db  
        

        # Check for training or prediction
        if type == 'train':
            self.y_data = np.loadtxt(y_file, skiprows=1, delimiter=",")  # Read output data file
            self.y_data = self.y_data.reshape(self.y_data.shape[0], -1)  # Reshape into 2D matrix (avoids array issues)
            # Compute epsilon based on the standard deviation of the output values for the RBFs that use it
            self.epsilon = np.std(self.y_data)

            self._train()  # Run the model training function

            # Store model parameters
            model_data = shelve.open(model_db)
            model_data['rbf_func'] = self.rbf_func
            model_data['epsilon'] = self.epsilon
            model_data['x_train'] = self.x_data
            model_data['weights'] = self.weights
            #print('\nSurrogate Data:')
            #print('RBF Function: ', model_data['rbf_func'])
            #print('Epsilon: ', model_data['epsilon'])
            #print('Radial Basis Function Weights: ', '\n', model_data['weights'])
            print('\n', 'Trained surrogate stored in: ', self.model_db)
            model_data.close()

        else:
            # Read previously stored model data from the database
            model_data = shelve.open(model_db)
            self.rbf_func = model_data['rbf_func']
            self.epsilon = model_data['epsilon']
            self.x_train = model_data['x_train']
            self.weights = model_data['weights']

            model_data.close()

            print('\nUsing', self.model_db, 'to predict values...')
            self._predict()  # Run the model prediction function

            # Quick loop to add a header that matches the input file format
            y_head = []
            for i in range(self.y_pred.shape[1]):
                y_head.append('y' + str(i))

            # Convert header list of strings to a single string with commas and write out the predictions to a file
            header = ','.join(y_head)
            np.savetxt('y_pred.dat', self.y_pred, delimiter=',', fmt="%.6f", header=header, comments='')
            print('Predicted values stored in \"y_pred.dat\"')

    # Create and run the RBF class object
surrogate = RBF('predict', 'input_RBF_predict.csv', 'MCS_list_output_RBF_predict.csv', 'problem2_trained_model.csv', 'multiquadratic')

df_predicted_problem_2=pd.read_csv('y_pred.dat')

df_predicted_problem_2.values.flatten()
sum(n < 0 for n in df_predicted_problem_2.values.flatten())
probability_of_failure=sum(n < 0 for n in df_predicted_problem_2.values.flatten())/n_P2
print("Probability of Failure=",probability_of_failure)

"""


# Problem 3 Direct MCS 
"""

n3=1000000
Mn=211.20*10**6
mux1=1260  #=x
mux2=250   #=y
mux3=770   #=z
mux4=0.55  #=a
mux5=30    #=b
mux6=250   #=c

sigx1=63      #
sigx2= 17.5   #
sigx3=10      #
sigx4=0.055   #
sigx5=4.5     #
sigx6=5       #

#lognormla parameter calculation

## X1 parameter for entry

normal_std_x1 = np.sqrt(np.log(1 + (sigx1/mux1)**2))
normal_mean_x1 = np.log(mux1) - normal_std_x1**2 / 2
print(normal_std_x1,normal_mean_x1)

normal_std_x2 = np.sqrt(np.log(1 + (sigx2/mux2)**2))
normal_mean_x2 = np.log(mux2) - normal_std_x2**2 / 2
print(normal_std_x2,normal_mean_x2)

normal_std_x3 = np.sqrt(np.log(1 + (sigx3/mux3)**2))
normal_mean_x3 = np.log(mux3) - normal_std_x3**2 / 2
print(normal_std_x3,normal_mean_x3)

normal_std_x4 = np.sqrt(np.log(1 + (sigx4/mux4)**2))
normal_mean_x4 = np.log(mux4) - normal_std_x4**2 / 2
print(normal_std_x4,normal_mean_x4)

normal_std_x5 = np.sqrt(np.log(1 + (sigx1/mux5)**2))
normal_mean_x5 = np.log(mux5) - normal_std_x5**2 / 2
print(normal_std_x5,normal_mean_x5)

normal_std_x6 = np.sqrt(np.log(1 + (sigx6/mux6)**2))
normal_mean_x6 = np.log(mux6) - normal_std_x6**2 / 2
print(normal_std_x6,normal_mean_x6)

def Y_3(x,y,z,a,b,c):
  value=-211.20*10**6+x*y*z-((a*(x**2)*(y**2))/(b*c))
  return value
mean=Y_3(mux1,mux2,mux3,mux4,mux5,mux6)
print(mean)

MCS_list_3_output=[]
mcs_x1_input=[]
mcs_x2_input=[]
mcs_x3_input=[]
mcs_x4_input=[]
mcs_x5_input=[]
mcs_x6_input=[]

for i in range(n3):
    mcs_x1_sample=np.random.lognormal(normal_mean_x1,normal_std_x1)
    mcs_x2_sample=np.random.lognormal(normal_mean_x2,normal_std_x2)
    mcs_x3_sample=np.random.lognormal(normal_mean_x3,normal_std_x3)
    mcs_x4_sample=np.random.lognormal(normal_mean_x4,normal_std_x4)
    mcs_x5_sample=np.random.lognormal(normal_mean_x5,normal_std_x5)
    mcs_x6_sample=np.random.lognormal(normal_mean_x6,normal_std_x6)

    mcs_3_sample=Y_3(mcs_x1_sample,mcs_x2_sample,mcs_x3_sample,mcs_x4_sample,mcs_x5_sample,mcs_x6_sample)
    MCS_list_3_output.append(mcs_3_sample)

    mcs_x1_input.append(mcs_x1_sample)
    mcs_x2_input.append(mcs_x2_sample)
    mcs_x3_input.append(mcs_x3_sample)
    mcs_x4_input.append(mcs_x4_sample)
    mcs_x5_input.append(mcs_x5_sample)
    mcs_x6_input.append(mcs_x6_sample)
#print(mcs_x1_input)
#print(MCS_list_3_output)

Failure_points=[x for x in MCS_list_3_output if x<0]
length=len(Failure_points)
PF=length/n3
print("Probability Of Failure=",PF)

"""# **RBF Model Training for Problem 3**"""

n3_predict=80
Mn=211.20*10**6
mux1=1260  #=x
mux2=250   #=y
mux3=770   #=z
mux4=0.55  #=a
mux5=30    #=b
mux6=250   #=c

sigx1=63      #
sigx2= 17.5   #
sigx3=10      #
sigx4=0.055   #
sigx5=4.5     #
sigx6=5       #

#lognormla parameter calculation

## X1 parameter for entry

normal_std_x1 = np.sqrt(np.log(1 + (sigx1/mux1)**2))
normal_mean_x1 = np.log(mux1) - normal_std_x1**2 / 2
print(normal_std_x1,normal_mean_x1)

normal_std_x2 = np.sqrt(np.log(1 + (sigx2/mux2)**2))
normal_mean_x2 = np.log(mux2) - normal_std_x2**2 / 2
print(normal_std_x2,normal_mean_x2)

normal_std_x3 = np.sqrt(np.log(1 + (sigx3/mux3)**2))
normal_mean_x3 = np.log(mux3) - normal_std_x3**2 / 2
print(normal_std_x3,normal_mean_x3)

normal_std_x4 = np.sqrt(np.log(1 + (sigx4/mux4)**2))
normal_mean_x4 = np.log(mux4) - normal_std_x4**2 / 2
print(normal_std_x4,normal_mean_x4)

normal_std_x5 = np.sqrt(np.log(1 + (sigx1/mux5)**2))
normal_mean_x5 = np.log(mux5) - normal_std_x5**2 / 2
print(normal_std_x5,normal_mean_x5)

normal_std_x6 = np.sqrt(np.log(1 + (sigx6/mux6)**2))
normal_mean_x6 = np.log(mux6) - normal_std_x6**2 / 2
print(normal_std_x6,normal_mean_x6)

def Y_3(x,y,z,a,b,c):
  value=-211.20*10**6+x*y*z-((a*(x**2)*(y**2))/(b*c))
  return value

MCS_list_3_output=[]
mcs_x1_input=[]
mcs_x2_input=[]
mcs_x3_input=[]
mcs_x4_input=[]
mcs_x5_input=[]
mcs_x6_input=[]

for i in range(n3_predict):
    mcs_x1_sample=np.random.lognormal(normal_mean_x1,normal_std_x1)
    mcs_x2_sample=np.random.lognormal(normal_mean_x2,normal_std_x2)
    mcs_x3_sample=np.random.lognormal(normal_mean_x3,normal_std_x3)
    mcs_x4_sample=np.random.lognormal(normal_mean_x4,normal_std_x4)
    mcs_x5_sample=np.random.lognormal(normal_mean_x5,normal_std_x5)
    mcs_x6_sample=np.random.lognormal(normal_mean_x6,normal_std_x6)

    mcs_3_sample=Y_3(mcs_x1_sample,mcs_x2_sample,mcs_x3_sample,mcs_x4_sample,mcs_x5_sample,mcs_x6_sample)
    MCS_list_3_output.append(mcs_3_sample)

    mcs_x1_input.append(mcs_x1_sample)
    mcs_x2_input.append(mcs_x2_sample)
    mcs_x3_input.append(mcs_x3_sample)
    mcs_x4_input.append(mcs_x4_sample)
    mcs_x5_input.append(mcs_x5_sample)
    mcs_x6_input.append(mcs_x6_sample)

# save to csv file
savetxt('mcs_x1_input.csv', mcs_x1_input, delimiter=',')
savetxt('mcs_x2_input.csv', mcs_x2_input, delimiter=',')
savetxt('mcs_x3_input.csv', mcs_x3_input, delimiter=',')
savetxt('mcs_x4_input.csv', mcs_x4_input, delimiter=',')
savetxt('mcs_x5_input.csv', mcs_x5_input, delimiter=',')
savetxt('mcs_x6_input.csv',mcs_x6_input, delimiter=',')
df1_RBF_3=pd.read_csv('mcs_x1_input.csv')
df2_RBF_3=pd.read_csv('mcs_x2_input.csv')
df3_RBF_3=pd.read_csv('mcs_x3_input.csv')
df4_RBF_3=pd.read_csv('mcs_x4_input.csv')
df5_RBF_3=pd.read_csv('mcs_x5_input.csv')
df6_RBF_3=pd.read_csv('mcs_x6_input.csv')
input_df_RBF_3=pd.concat([df1_RBF_3,df2_RBF_3,df3_RBF_3,df4_RBF_3,df5_RBF_3,df6_RBF_3], axis=1)
savetxt('input_RBF_3.csv', input_df_RBF_3, delimiter=',')
savetxt('MCS_list_3_output.csv',  MCS_list_3_output, delimiter=',')
output_df_RBF_3=pd.read_csv('MCS_list_3_output.csv')

print(input_df_RBF_3.shape)
#print(MCS_list_3_output)



# Class to create or use an RBF surrogate model
class RBF:

    
    # Multiquadratic
    def _multiquadric(self, r):
        return np.sqrt(r ** 2 + self.epsilon ** 2)

    

    # radial distance calculation - r = (x-c)
    def _compute_r(self, a, b=None):
        if b is not None:
            #  distance matrix between two matrices or vectors)
            return cdist(a, b, 'minkowski', p=2)
        else:
            # square matrix formation of the the pairwise distance distance for the training locations
            return squareform(pdist(a, 'minkowski', p=2))

    def _compute_N(self, r):

      #dictionary to call our MQ_RBF function
        rbf_dict = {
            "multiquadratic" : self._multiquadric,
          
        }

        return rbf_dict[self.rbf_func](r)

    # Function to train an RBF surrogate using the suplied data and options
    def _train(self):
        r = self._compute_r(self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the specified type
        self.weights = np.linalg.solve(N, self.y_data)  # Solve for the weights vector
            # Predicting Y for given combination of input variables
    def _predict(self):
        r = self._compute_r(self.x_train, self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the trained type
        self.y_pred = np.matmul(N.T, self.weights)  # Use the surrogate to predict new y values
        
          
   #inputs
    def __init__(self, type, x_file='x_train.dat', y_file='y_train.dat', model_db='model.db', rbf_func='gaussian'):

        self.x_data = np.loadtxt(x_file, skiprows=0, delimiter=",")  
        self.x_data = self.x_data.reshape(self.x_data.shape[0], -1)  
        self.rbf_func = rbf_func  
        self.model_db = model_db  
        

        # Check for training or prediction
        if type == 'train':
            self.y_data = np.loadtxt(y_file, skiprows=1, delimiter=",")  # Read output data file
            self.y_data = self.y_data.reshape(self.y_data.shape[0], -1)  # Reshape into 2D matrix (avoids array issues)
            # Compute epsilon based on the standard deviation of the output values for the RBFs that use it
            self.epsilon = np.std(self.y_data)

            self._train()  # Run the model training function

            # Store model parameters
            model_data = shelve.open(model_db)
            model_data['rbf_func'] = self.rbf_func
            model_data['epsilon'] = self.epsilon
            model_data['x_train'] = self.x_data
            model_data['weights'] = self.weights
            #print('\nSurrogate Data:')
            #print('RBF Function: ', model_data['rbf_func'])
            #print('Epsilon: ', model_data['epsilon'])
            #print('Radial Basis Function Weights: ', '\n', model_data['weights'])
            print('\n', 'Trained surrogate stored in: ', self.model_db)
            model_data.close()

        else:
            # Read previously stored model data from the database
            model_data = shelve.open(model_db)
            self.rbf_func = model_data['rbf_func']
            self.epsilon = model_data['epsilon']
            self.x_train = model_data['x_train']
            self.weights = model_data['weights']

            model_data.close()

            print('\nUsing', self.model_db, 'to predict values...')
            self._predict()  # Run the model prediction function

            # Quick loop to add a header that matches the input file format
            y_head = []
            for i in range(self.y_pred.shape[1]):
                y_head.append('y' + str(i))

            # Convert header list of strings to a single string with commas and write out the predictions to a file
            header = ','.join(y_head)
            np.savetxt('y_pred.dat', self.y_pred, delimiter=',', fmt="%.6f", header=header, comments='')
            print('Predicted values stored in \"y_pred.dat\"')

    # Create and run the RBF class object
surrogate = RBF('train', 'input_RBF_3.csv', 'MCS_list_3_output.csv', 'problem3_trained_model.csv', 'multiquadratic')

"""# **Predicting from the output for problem 3**"""

mcs_x1_input_predict=[]
mcs_x2_input_predict=[]
mcs_x3_input_predict=[]
mcs_x4_input_predict=[]
mcs_x5_input_predict=[]
mcs_x6_input_predict=[]

for i in range(n3):
    mcs_x1_sample_predict=np.random.lognormal(normal_mean_x1,normal_std_x1)
    mcs_x2_sample_predict=np.random.lognormal(normal_mean_x2,normal_std_x2)
    mcs_x3_sample_predict=np.random.lognormal(normal_mean_x3,normal_std_x3)
    mcs_x4_sample_predict=np.random.lognormal(normal_mean_x4,normal_std_x4)
    mcs_x5_sample_predict=np.random.lognormal(normal_mean_x5,normal_std_x5)
    mcs_x6_sample_predict=np.random.lognormal(normal_mean_x6,normal_std_x6)

   

    mcs_x1_input_predict.append(mcs_x1_sample_predict)
    mcs_x2_input_predict.append(mcs_x2_sample_predict)
    mcs_x3_input_predict.append(mcs_x3_sample_predict)
    mcs_x4_input_predict.append(mcs_x4_sample_predict)
    mcs_x5_input_predict.append(mcs_x5_sample_predict)
    mcs_x6_input_predict.append(mcs_x6_sample_predict)


#print(mcs_x3_input_predict)

savetxt('mcs_x1_input_predict.csv', mcs_x1_input_predict, delimiter=',')
savetxt('mcs_x2_input_predict.csv', mcs_x2_input_predict, delimiter=',')
savetxt('mcs_x3_input_predict.csv', mcs_x3_input_predict, delimiter=',')
savetxt('mcs_x4_input_predict.csv',mcs_x4_input_predict, delimiter=',')
savetxt('mcs_x5_input_predict.csv',mcs_x5_input_predict, delimiter=',')
savetxt('mcs_x6_input_predict.csv',mcs_x6_input_predict, delimiter=',')
df1_RBF_predict_3=pd.read_csv('mcs_x1_input_predict.csv')
df2_RBF_predict_3=pd.read_csv('mcs_x2_input_predict.csv')
df3_RBF_predict_3=pd.read_csv('mcs_x3_input_predict.csv')
df4_RBF_predict_3=pd.read_csv('mcs_x4_input_predict.csv')
df5_RBF_predict_3=pd.read_csv('mcs_x5_input_predict.csv')
df6_RBF_predict_3=pd.read_csv('mcs_x6_input_predict.csv')
input_df_RBF_predict=pd.concat([df1_RBF_predict_3,df2_RBF_predict_3,df3_RBF_predict_3,df4_RBF_predict_3,df5_RBF_predict_3,df6_RBF_predict_3], axis=1)
savetxt('input_RBF_predict_3.csv', input_df_RBF_predict, delimiter=',')

# Class to create or use an RBF surrogate model
class RBF:

    
    # Multiquadratic
    def _multiquadric(self, r):
        return np.sqrt(r ** 2 + self.epsilon ** 2)

    

    # radial distance calculation - r = (x-c)
    def _compute_r(self, a, b=None):
        if b is not None:
            #  distance matrix between two matrices or vectors)
            return cdist(a, b, 'minkowski', p=2)
        else:
            # square matrix formation of the the pairwise distance distance for the training locations
            return squareform(pdist(a, 'minkowski', p=2))

    def _compute_N(self, r):

      #dictionary to call our MQ_RBF function
        rbf_dict = {
            "multiquadratic" : self._multiquadric,
          
        }

        return rbf_dict[self.rbf_func](r)

    # Function to train an RBF surrogate using the suplied data and options
    def _train(self):
        r = self._compute_r(self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the specified type
        self.weights = np.linalg.solve(N, self.y_data)  # Solve for the weights vector
            # Predicting Y for given combination of input variables
    def _predict(self):
        r = self._compute_r(self.x_train, self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the trained type
        self.y_pred = np.matmul(N.T, self.weights)  # Use the surrogate to predict new y values
        
          
   #inputs
    def __init__(self, type, x_file='x_train.dat', y_file='y_train.dat', model_db='model.db', rbf_func='gaussian'):

        self.x_data = np.loadtxt(x_file, skiprows=0, delimiter=",")  
        self.x_data = self.x_data.reshape(self.x_data.shape[0], -1)  
        self.rbf_func = rbf_func  
        self.model_db = model_db  
        

        # Check for training or prediction
        if type == 'train':
            self.y_data = np.loadtxt(y_file, skiprows=1, delimiter=",")  # Read output data file
            self.y_data = self.y_data.reshape(self.y_data.shape[0], -1)  # Reshape into 2D matrix (avoids array issues)
            # Compute epsilon based on the standard deviation of the output values for the RBFs that use it
            self.epsilon = np.std(self.y_data)

            self._train()  # Run the model training function

            # Store model parameters
            model_data = shelve.open(model_db)
            model_data['rbf_func'] = self.rbf_func
            model_data['epsilon'] = self.epsilon
            model_data['x_train'] = self.x_data
            model_data['weights'] = self.weights
            #print('\nSurrogate Data:')
            #print('RBF Function: ', model_data['rbf_func'])
            #print('Epsilon: ', model_data['epsilon'])
            #print('Radial Basis Function Weights: ', '\n', model_data['weights'])
            print('\n', 'Trained surrogate stored in: ', self.model_db)
            model_data.close()

        else:
            # Read previously stored model data from the database
            model_data = shelve.open(model_db)
            self.rbf_func = model_data['rbf_func']
            self.epsilon = model_data['epsilon']
            self.x_train = model_data['x_train']
            self.weights = model_data['weights']

            model_data.close()

            print('\nUsing', self.model_db, 'to predict values...')
            self._predict()  # Run the model prediction function

            # Quick loop to add a header that matches the input file format
            y_head = []
            for i in range(self.y_pred.shape[1]):
                y_head.append('y' + str(i))

            # Convert header list of strings to a single string with commas and write out the predictions to a file
            header = ','.join(y_head)
            np.savetxt('y_pred.dat', self.y_pred, delimiter=',', fmt="%.6f", header=header, comments='')
            print('Predicted values stored in \"y_pred.dat\"')

    # Create and run the RBF class object
surrogate = RBF('predict', 'input_RBF_predict_3.csv', 'MCS_list_output_RBF_predict_3.csv', 'problem3_trained_model.csv', 'multiquadratic')

df_predicted_problem_3=pd.read_csv('y_pred.dat')
df_predicted_problem_3.values.flatten()
sum(n < 0 for n in df_predicted_problem_3.values.flatten())
probability_of_failure=sum(n < 0 for n in df_predicted_problem_3.values.flatten())/n3
print("Probability of Failure=",probability_of_failure)

"""# **Problem 4-Burst Margin Of rotating Disk**

"""

n_4 = 1000000  # number of samples
k = 0.958     # shape
lam = 25.508   # scale


mu_s_u=220000
sig_s_u=5000
    

a_rho=0.28
b_rho=0.3


mu_omega=21000
sig_omega=1000
    


mu_R0=24
sig_R0=0.5
    


mu_Ri=8
sig_Ri=0.3
    

#print(Ri_gauss)
#x=alpha_m
#y=s_u_gauss
#z=rho_uniform
#m=omega_gauss
#n=R0_gauss
#o=Ri_gauss
def Mb(x,y,z,m,n,o):
    return math.sqrt((((x*y)/(z*(2*math.pi*m/60)**2))*(n**3-o**3)/(3*385.82*(n-o))))-0.37473

MCS_list_output_4=[]
mcs_alpha_m_input=[]
mcs_s_u_gauss_input=[]
mcs_rho_uniform_input=[]
mcs_omega_gauss_input=[]
mcs_R0_gauss_input=[]
mcs_Ri_gauss_input=[]

for i in range(n_4):
    mcs_alpha_m_sample=weibull_min.rvs(k, loc=0, scale=lam)
    mcs_s_u_gauss_sample=random.gauss(mu_s_u,sig_s_u)
    mcs_rho_uniform_sample=random.uniform(a_rho,b_rho)
    mcs_omega_gauss_sample=random.gauss(mu_omega,sig_omega)
    mcs_R0_gauss_sample=random.gauss(mu_R0,sig_R0)
    mcs_Ri_gauss_sample=random.gauss(mu_Ri,sig_Ri)
    
    mcs_sample_4=Mb(mcs_alpha_m_sample,mcs_s_u_gauss_sample,mcs_rho_uniform_sample,mcs_omega_gauss_sample,mcs_R0_gauss_sample,mcs_Ri_gauss_sample)
    
    MCS_list_output_4.append(mcs_sample_4)
    mcs_alpha_m_input.append(mcs_alpha_m_sample)
    mcs_s_u_gauss_input.append(mcs_s_u_gauss_sample)
    mcs_rho_uniform_input.append(mcs_rho_uniform_sample)
    mcs_omega_gauss_input.append( mcs_omega_gauss_sample)
    mcs_R0_gauss_input.append(mcs_R0_gauss_sample)
    mcs_Ri_gauss_input.append( mcs_Ri_gauss_sample)
#print(MCS_list_output_4)

Failure_points=[x for x in MCS_list_output_4 if x<0]
#print(Failure_points)
length=len(Failure_points)
PF=length/n_4
print("Probability Of Failure=",PF)
#print("Reliability Index=",norm.ppf(PF))



"""# **Model Training for Problem 4**"""

n_4_predict = 70  # number of samples
k = 0.958     # shape
lam = 25.508   # scale


mu_s_u=220000
sig_s_u=5000
    

a_rho=0.28
b_rho=0.3


mu_omega=21000
sig_omega=1000
    


mu_R0=24
sig_R0=0.5
    


mu_Ri=8
sig_Ri=0.3
    

#print(Ri_gauss)
#x=alpha_m
#y=s_u_gauss
#z=rho_uniform
#m=omega_gauss
#n=R0_gauss
#o=Ri_gauss
def Mb(x,y,z,m,n,o):
    return math.sqrt((((x*y)/(z*(2*math.pi*m/60)**2))*(n**3-o**3)/(3*385.82*(n-o))))-0.37473

MCS_list_output_4=[]
mcs_alpha_m_input=[]
mcs_s_u_gauss_input=[]
mcs_rho_uniform_input=[]
mcs_omega_gauss_input=[]
mcs_R0_gauss_input=[]
mcs_Ri_gauss_input=[]

for i in range(n_4_predict):
    mcs_alpha_m_sample=weibull_min.rvs(k, loc=0, scale=lam)
    mcs_s_u_gauss_sample=random.gauss(mu_s_u,sig_s_u)
    mcs_rho_uniform_sample=random.uniform(a_rho,b_rho)
    mcs_omega_gauss_sample=random.gauss(mu_omega,sig_omega)
    mcs_R0_gauss_sample=random.gauss(mu_R0,sig_R0)
    mcs_Ri_gauss_sample=random.gauss(mu_Ri,sig_Ri)
    
    mcs_sample_4=Mb(mcs_alpha_m_sample,mcs_s_u_gauss_sample,mcs_rho_uniform_sample,mcs_omega_gauss_sample,mcs_R0_gauss_sample,mcs_Ri_gauss_sample)
    
    MCS_list_output_4.append(mcs_sample_4)
    mcs_alpha_m_input.append(mcs_alpha_m_sample)
    mcs_s_u_gauss_input.append(mcs_s_u_gauss_sample)
    mcs_rho_uniform_input.append(mcs_rho_uniform_sample)
    mcs_omega_gauss_input.append( mcs_omega_gauss_sample)
    mcs_R0_gauss_input.append(mcs_R0_gauss_sample)
    mcs_Ri_gauss_input.append( mcs_Ri_gauss_sample)
#print(MCS_list_output_4)

# save to csv file
savetxt('mcs_alpha_m_input.csv', mcs_alpha_m_input, delimiter=',')
savetxt('mcs_s_u_gauss_input.csv', mcs_s_u_gauss_input, delimiter=',')
savetxt('mcs_rho_uniform_input.csv', mcs_rho_uniform_input, delimiter=',')
savetxt('mcs_omega_gauss_input.csv', mcs_omega_gauss_input, delimiter=',')
savetxt('mcs_R0_gauss_input.csv', mcs_R0_gauss_input, delimiter=',')
savetxt('mcs_Ri_gauss_input.csv',mcs_Ri_gauss_input, delimiter=',')
df1_RBF_4=pd.read_csv('mcs_alpha_m_input.csv')
df2_RBF_4=pd.read_csv('mcs_s_u_gauss_input.csv')
df3_RBF_4=pd.read_csv('mcs_rho_uniform_input.csv')
df4_RBF_4=pd.read_csv('mcs_omega_gauss_input.csv')
df5_RBF_4=pd.read_csv('mcs_R0_gauss_input.csv')
df6_RBF_4=pd.read_csv('mcs_Ri_gauss_input.csv')
input_df_RBF=pd.concat([df1_RBF_4,df2_RBF_4,df3_RBF_4,df4_RBF_4,df5_RBF_4,df6_RBF_4], axis=1)
savetxt('input_RBF_4.csv', input_df_RBF, delimiter=',')
savetxt('MCS_list_output_4.csv',  MCS_list_output_4, delimiter=',')
output_df_RBF_4=pd.read_csv('MCS_list_output_4.csv')

#print(input_df_RBF)
#print(MCS_list_output_RBF)



"""# **Input to RBF model problem 4**"""

# Class to create or use an RBF surrogate model
class RBF:

    
    # Multiquadratic
    def _multiquadric(self, r):
        return np.sqrt(r ** 2 + self.epsilon ** 2)

    

    # radial distance calculation - r = (x-c)
    def _compute_r(self, a, b=None):
        if b is not None:
            #  distance matrix between two matrices or vectors)
            return cdist(a, b, 'minkowski', p=2)
        else:
            # square matrix formation of the the pairwise distance distance for the training locations
            return squareform(pdist(a, 'minkowski', p=2))

    def _compute_N(self, r):

      #dictionary to call our MQ_RBF function
        rbf_dict = {
            "multiquadratic" : self._multiquadric,
          
        }

        return rbf_dict[self.rbf_func](r)

    # Function to train an RBF surrogate using the suplied data and options
    def _train(self):
        r = self._compute_r(self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the specified type
        self.weights = np.linalg.solve(N, self.y_data)  # Solve for the weights vector
            # Predicting Y for given combination of input variables
    def _predict(self):
        r = self._compute_r(self.x_train, self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the trained type
        self.y_pred = np.matmul(N.T, self.weights)  # Use the surrogate to predict new y values
        
          
   #inputs
    def __init__(self, type, x_file='x_train.dat', y_file='y_train.dat', model_db='model.db', rbf_func='gaussian'):

        self.x_data = np.loadtxt(x_file, skiprows=0, delimiter=",")  
        self.x_data = self.x_data.reshape(self.x_data.shape[0], -1)  
        self.rbf_func = rbf_func  
        self.model_db = model_db  
        

        # Check for training or prediction
        if type == 'train':
            self.y_data = np.loadtxt(y_file, skiprows=1, delimiter=",")  # Read output data file
            self.y_data = self.y_data.reshape(self.y_data.shape[0], -1)  # Reshape into 2D matrix (avoids array issues)
            # Compute epsilon based on the standard deviation of the output values for the RBFs that use it
            self.epsilon = np.std(self.y_data)

            self._train()  # Run the model training function

            # Store model parameters
            model_data = shelve.open(model_db)
            model_data['rbf_func'] = self.rbf_func
            model_data['epsilon'] = self.epsilon
            model_data['x_train'] = self.x_data
            model_data['weights'] = self.weights
            #print('\nSurrogate Data:')
            #print('RBF Function: ', model_data['rbf_func'])
            #print('Epsilon: ', model_data['epsilon'])
            #print('Radial Basis Function Weights: ', '\n', model_data['weights'])
            print('\n', 'Trained surrogate stored in: ', self.model_db)
            model_data.close()

        else:
            # Read previously stored model data from the database
            model_data = shelve.open(model_db)
            self.rbf_func = model_data['rbf_func']
            self.epsilon = model_data['epsilon']
            self.x_train = model_data['x_train']
            self.weights = model_data['weights']

            model_data.close()

            print('\nUsing', self.model_db, 'to predict values...')
            self._predict()  # Run the model prediction function

            # Quick loop to add a header that matches the input file format
            y_head = []
            for i in range(self.y_pred.shape[1]):
                y_head.append('y' + str(i))

            # Convert header list of strings to a single string with commas and write out the predictions to a file
            header = ','.join(y_head)
            np.savetxt('y_pred.dat', self.y_pred, delimiter=',', fmt="%.6f", header=header, comments='')
            print('Predicted values stored in \"y_pred.dat\"')

    # Create and run the RBF class object
surrogate = RBF('train', 'input_RBF_4.csv', 'MCS_list_output_4.csv', 'problem4_trained_model.csv', 'multiquadratic')



"""# **Predicting the output and Probability of failure for problem 4**"""

mcs_alpha_m_input_predict=[]
mcs_s_u_gauss_input_predict=[]
mcs_rho_uniform_input_predict=[]
mcs_omega_gauss_input_predict=[]
mcs_R0_gauss_input_predict=[]
mcs_Ri_gauss_input_predict=[]

for i in range(n_4):
    mcs_alpha_m_sample_predict=weibull_min.rvs(k, loc=0, scale=lam)
    mcs_s_u_gauss_sample_predict=random.gauss(mu_s_u,sig_s_u)
    mcs_rho_uniform_sample_predict=random.uniform(a_rho,b_rho)
    mcs_omega_gauss_sample_predict=random.gauss(mu_omega,sig_omega)
    mcs_R0_gauss_sample_predict=random.gauss(mu_R0,sig_R0)
    mcs_Ri_gauss_sample_predict=random.gauss(mu_Ri,sig_Ri)
    
    
    mcs_alpha_m_input_predict.append(mcs_alpha_m_sample_predict)
    mcs_s_u_gauss_input_predict.append(mcs_s_u_gauss_sample_predict)
    mcs_rho_uniform_input_predict.append(mcs_rho_uniform_sample_predict)
    mcs_omega_gauss_input_predict.append( mcs_omega_gauss_sample_predict)
    mcs_R0_gauss_input_predict.append(mcs_R0_gauss_sample_predict)
    mcs_Ri_gauss_input_predict.append( mcs_Ri_gauss_sample_predict)

savetxt('mcs_alpha_m_input_predict.csv', mcs_alpha_m_input_predict, delimiter=',')
savetxt('mcs_s_u_gauss_input_predict.csv', mcs_s_u_gauss_input_predict, delimiter=',')
savetxt('mcs_rho_uniform_input_predict.csv', mcs_rho_uniform_input_predict, delimiter=',')
savetxt('mcs_omega_gauss_input_predict.csv', mcs_omega_gauss_input_predict, delimiter=',')
savetxt('mcs_R0_gauss_input_predict.csv', mcs_R0_gauss_input_predict, delimiter=',')
savetxt('mcs_Ri_gauss_input_predict.csv',mcs_Ri_gauss_input_predict, delimiter=',')
df1_RBF_predict_4=pd.read_csv('mcs_alpha_m_input_predict.csv')
df2_RBF_predict_4=pd.read_csv('mcs_s_u_gauss_input_predict.csv')
df3_RBF_predict_4=pd.read_csv('mcs_rho_uniform_input_predict.csv')
df4_RBF_predict_4=pd.read_csv('mcs_omega_gauss_input_predict.csv')
df5_RBF_predict_4=pd.read_csv('mcs_R0_gauss_input_predict.csv')
df6_RBF_predict_4=pd.read_csv('mcs_Ri_gauss_input_predict.csv')
input_df_RBF_predict=pd.concat([df1_RBF_predict_4,df2_RBF_predict_4,df3_RBF_predict_4,df4_RBF_predict_4,df5_RBF_predict_4,df6_RBF_predict_4], axis=1)
savetxt('input_RBF_predict_4.csv', input_df_RBF_predict, delimiter=',')

# Class to create or use an RBF surrogate model
class RBF:

    
    # Multiquadratic
    def _multiquadric(self, r):
        return np.sqrt(r ** 2 + self.epsilon ** 2)

    

    # radial distance calculation - r = (x-c)
    def _compute_r(self, a, b=None):
        if b is not None:
            #  distance matrix between two matrices or vectors)
            return cdist(a, b, 'minkowski', p=2)
        else:
            # square matrix formation of the the pairwise distance distance for the training locations
            return squareform(pdist(a, 'minkowski', p=2))

    def _compute_N(self, r):

      #dictionary to call our MQ_RBF function
        rbf_dict = {
            "multiquadratic" : self._multiquadric,
          
        }

        return rbf_dict[self.rbf_func](r)

    # Function to train an RBF surrogate using the suplied data and options
    def _train(self):
        r = self._compute_r(self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the specified type
        self.weights = np.linalg.solve(N, self.y_data)  # Solve for the weights vector
            # Predicting Y for given combination of input variables
    def _predict(self):
        r = self._compute_r(self.x_train, self.x_data)  # Compute the euclidean distance matrix
        N = self._compute_N(r)  # Compute the basis function matrix of the trained type
        self.y_pred = np.matmul(N.T, self.weights)  # Use the surrogate to predict new y values
        
          
   #inputs
    def __init__(self, type, x_file='x_train.dat', y_file='y_train.dat', model_db='model.db', rbf_func='gaussian'):

        self.x_data = np.loadtxt(x_file, skiprows=0, delimiter=",")  
        self.x_data = self.x_data.reshape(self.x_data.shape[0], -1)  
        self.rbf_func = rbf_func  
        self.model_db = model_db  
        

        # Check for training or prediction
        if type == 'train':
            self.y_data = np.loadtxt(y_file, skiprows=1, delimiter=",")  # Read output data file
            self.y_data = self.y_data.reshape(self.y_data.shape[0], -1)  # Reshape into 2D matrix (avoids array issues)
            # Compute epsilon based on the standard deviation of the output values for the RBFs that use it
            self.epsilon = np.std(self.y_data)

            self._train()  # Run the model training function

            # Store model parameters
            model_data = shelve.open(model_db)
            model_data['rbf_func'] = self.rbf_func
            model_data['epsilon'] = self.epsilon
            model_data['x_train'] = self.x_data
            model_data['weights'] = self.weights
            #print('\nSurrogate Data:')
            #print('RBF Function: ', model_data['rbf_func'])
            #print('Epsilon: ', model_data['epsilon'])
            #print('Radial Basis Function Weights: ', '\n', model_data['weights'])
            print('\n', 'Trained surrogate stored in: ', self.model_db)
            model_data.close()

        else:
            # Read previously stored model data from the database
            model_data = shelve.open(model_db)
            self.rbf_func = model_data['rbf_func']
            self.epsilon = model_data['epsilon']
            self.x_train = model_data['x_train']
            self.weights = model_data['weights']

            model_data.close()

            print('\nUsing', self.model_db, 'to predict values...')
            self._predict()  # Run the model prediction function

            # Quick loop to add a header that matches the input file format
            y_head = []
            for i in range(self.y_pred.shape[1]):
                y_head.append('y' + str(i))

            # Convert header list of strings to a single string with commas and write out the predictions to a file
            header = ','.join(y_head)
            np.savetxt('y_pred.dat', self.y_pred, delimiter=',', fmt="%.6f", header=header, comments='')
            print('Predicted values stored in \"y_pred.dat\"')

    # Create and run the RBF class object
surrogate = RBF('predict', 'input_RBF_predict_4.csv', 'MCS_list_output_RBF_predict_4.csv', 'problem4_trained_model.csv', 'multiquadratic')

df_predicted_problem_4=pd.read_csv('y_pred.dat')
df_predicted_problem_4.values.flatten()
sum(n < 0 for n in df_predicted_problem_4.values.flatten())
probability_of_failure=sum(n < 0 for n in df_predicted_problem_4.values.flatten())/n_4
print("Probability of Failure=",probability_of_failure)